/*
export PKG_CONFIG_PATH=`pwd`/../../../lib/pkgconfig
export LD_LIBRARY_PATH=`pwd`/../../../lib
g++ -o main_train_proto main_train_proto.cc `pkg-config --cflags --libs lib_3d_mec_ginac-1.1 ginac gsl`
./main_train_proto DOWN NO
*/

#include <fstream>
#include "lib_3d_mec_ginac/lib_3d_mec_ginac.h"
#include <math.h>
#include <sstream>

using namespace std;
	
void printError(const char* arg){	printf("%s\n", arg);}	

int main(int argc, char *argv[]) {

if (argc!=3){ printf("Error: The program %s takes two parameters: Gravity (UP/DOWN) and Atomize (YES/NO)\n",argv[0]);	exit(1); }
	
if (0==strcmp(argv[1],"DOWN")){ gravity=DOWN; cout << "DOWN" << endl;}
else{
	if (0==strcmp(argv[1],"UP")){	gravity=UP; cout << "UP" << endl;	}
	else	{		printf("Error: The program %s takes two parameters: Gravity (UP/DOWN) and Atomize (YES/NO)\n",argv[0]);		exit(1);	}
}

if (0==strcmp(argv[2],"YES")){ atomization=YES; cout << "YES" << endl;}
else{
	if (0==strcmp(argv[2],"NO")){ atomization=NO; cout << "NO" << endl;}
	else	{ printf("Error: The program %s takes two parameters: Gravity (UP/DOWN) and Atomize (YES/NO)\n",argv[0]);	exit(1);}
}

double integration_time=strtod(argv[1], NULL);
double delta_t= strtod(argv[2], NULL);
long int k,steps;
	
printf("integration_time %g delta_t %g\n", integration_time, delta_t);

// SYSTEM DEFINITION
// ************************************************************************************************
	System sys(&printError);cout << "" << endl;
// ************************************************************************************************

#ifdef LAG
	#ifdef V_P
		cout << "" << endl;
		cout << "Elige SOLO 1 opcion: LAGRANGE o VIRTUAL POWER" << endl;
		cout << "" << endl;
		return 0;
	#endif
#endif
#ifndef LAG
	#ifndef V_P
		cout << "" << endl;
		cout << "Elige SOLO opcion: LAGRANGE o VIRTUAL POWER" << endl;
		cout << "" << endl;
	return 0;
	#endif
#endif

if (ORDER == CMO)
{
#define Col_MO
}


if (ORDER==RMO)
{
# define Row_MO
}

// ************************************************************************************************
// 3d_mec MODEL - PROTOTYPE ARESSE_TRAIN
// ************************************************************************************************
// Roberto Yoldi May-2012

// GENERALISED COORDINATES DEFINITION
// ************************************************************************************************
// q1,q2,q5,q6 are always indep
	// Gyroscope (solid 1) vs Inertial reference rotation. ROLL
	symbol_numeric q1	=	*sys.new_Coordinate("q1","dq1","ddq1", 0.0,0.0,0.0);
	// Road-Chassis (Solid 2) vs Gyroscope rotation. PITH
	symbol_numeric q2 = *sys.new_Coordinate("q2","dq2","ddq2", 0.0,0.0,0.0);
	// Wheel (solid 5) rotation vs Wheel-Chassis.
	symbol_numeric q5 = *sys.new_Coordinate("q5","dq5","ddq5", 0.0,0.0,0.0);
	// Mass (solid 6) rotation vs Road-Chassis rotation.
	symbol_numeric q6 = *sys.new_Coordinate("q6","dq6","ddq6", 0.0,0.0,0.0);


// q3 is indep is slip and dep if non slip
	// Road (solid 3) rotation vs Road-Chassis.
	symbol_numeric q3 = *sys.new_Coordinate("q3","dq3","ddq3", 0.0,0.0,0.0);


// q4 is always dep
	// Wheel-Chassis (solid 4) vs Road-Chassis rotation.
	symbol_numeric q4 = *sys.new_Coordinate("q4","dq4","ddq4", 0.0,0.0,0.0);


// KINEMATICAL PARAMETERS. STRUCTURE DIDMENSIONS & KINEMATIC CONSTANTS
// ************************************************************************************************
// Data from CAD
	symbol_numeric Sp	= *sys.new_Parameter("Sp",0.0900);
	symbol_numeric Lp	= *sys.new_Parameter("Lp",0.4325);
	symbol_numeric Ln	= *sys.new_Parameter("Ln",0.3848);
	symbol_numeric Ww	= *sys.new_Parameter("Ww",0.6500);
	symbol_numeric W 	= *sys.new_Parameter("W" ,0.3650);
	symbol_numeric Hn	= *sys.new_Parameter("Hn",0.6100);
	symbol_numeric Hi	= *sys.new_Parameter("Hi",0.2626);
	symbol_numeric Hs	= *sys.new_Parameter("Hs",0.2294);
	symbol_numeric Hb	= *sys.new_Parameter("Hb",0.4825);
	symbol_numeric Rw 	= *sys.new_Parameter("Rw",0.0750);
	symbol_numeric Rr 	= *sys.new_Parameter("Rr",0.0750);
	symbol_numeric Rx 	= *sys.new_Parameter("Rx",0.1550);
	symbol_numeric Bx 	= *sys.new_Parameter("Bx",0.0570);
	symbol_numeric Mx 	= *sys.new_Parameter("Mx",0.2318);
	symbol_numeric Si 	= *sys.new_Parameter("Si",0.4000);
	symbol_numeric Ss 	= *sys.new_Parameter("Ss",0.3427);
	ex     Hm	= Hb - Rw - Rr;

// Other data
//	symbol_numeric g	 	= *sys.new_Parameter("g",9.8);
//	symbol_numeric PI		= *sys.new_Parameter("pi",3.14159265358979);
//	symbol_numeric PI2	= *sys.new_Parameter("pi/2",3.14159265358979/2.0);
//	symbol_numeric SQR3 = *sys.new_Parameter("SQR3",1.73205080756888);

	symbol_numeric SR	= *sys.new_Parameter("SR",0.020);
	symbol_numeric VS	= *sys.new_Parameter("VS",1.000);

	symbol_numeric a1 	= *sys.new_Parameter("a1",3.14159265358979/12);
	symbol_numeric a2 	= *sys.new_Parameter("a2",3.14159265358979/4);

	symbol_numeric W1 	= *sys.new_Parameter("W1",3.14159265358979/4);
	symbol_numeric W2 	= *sys.new_Parameter("W2",3.14159265358979/2);
	symbol_numeric W3 	= *sys.new_Parameter("W3",0.0);
	symbol_numeric W4 	= *sys.new_Parameter("W4",3.14159265358979);
	symbol_numeric W5 	= *sys.new_Parameter("W5",3.14159265358979);

// Dynamic parameters
	symbol_numeric Ki		= *sys.new_Parameter("Ki",161000);
	symbol_numeric Li0	= *sys.new_Parameter("Li0",0.0500);
	symbol_numeric Li		= *sys.new_Parameter("Li",0.0400);

	symbol_numeric Ks		= *sys.new_Parameter("Ks",161000);
	symbol_numeric Ls0	= *sys.new_Parameter("Ls0",0.0500);
	symbol_numeric Ls		= *sys.new_Parameter("Ls",0.0400);

	symbol_numeric K		= *sys.new_Parameter("K",161000);
	symbol_numeric L0		= *sys.new_Parameter("L0",0.0500);
// L = L0 - ((mx6 * g) / (k * (Ln + Ss)));
	symbol_numeric L		= *sys.new_Parameter("L",(0.0500 - (((1.1543302E+01 * (+1.6951865E-03 -	(-0.3848))) * 9.8) / (161000 * (0.3848 + 0.3427)))));

	symbol_numeric Ds		= *sys.new_Parameter("Ds",0.3200);
//Di = Hi + Hs - Ds - L;
	symbol_numeric Di		= *sys.new_Parameter("Di",(0.2294 + 0.2626 - 0.3200 - (0.0500 - (((1.1543302E+01 * (+1.6951865E-03 -	(-0.3848))) * 9.8) / (161000 * (0.3848 + 0.3427))))));


// ************************************************************************************************
// KINEMATICS
// ************************************************************************************************

// Bases
// ------------------------------------------------------------------------------------------------
 	sys.new_Base("B1","xyz",0,1,0, q1);
 	sys.new_Base("B2","B1",1,0,0, q2);
 	sys.new_Base("B3","B2",1,0,0, q3);
 	sys.new_Base("B4","B2",0,1,0, q4);
 	sys.new_Base("B5","B4",1,0,0, q5);
 	sys.new_Base("B6","B2",0,1,0, q6);

// Vectors
// ------------------------------------------------------------------------------------------------
	Vector3D OO_OO = *sys.new_Vector3D("OO_OO",0.0,0.0,0.0,"xyz");
	Vector3D OO_O1 = *sys.new_Vector3D("OO_O1",0.0,0.0,0.0,"xyz");
	Vector3D O1_O2 = *sys.new_Vector3D("O1_O2",0.0,0.0,+Sp,"B1");
	Vector3D O2_O3 = *sys.new_Vector3D("O2_O3",+Rx,0.0,-(Sp+Hb),"B2");
	Vector3D O2_O4 = *sys.new_Vector3D("O2_O4",-Ln,0.0,-(Sp+Hi),"B2");
	Vector3D O4_O5 = *sys.new_Vector3D("O4_O5",(Ln+Rx),0.0,-(Hm-Hi),"B4");
	Vector3D O2_O6 = *sys.new_Vector3D("O2_O6",-Ln,0.0,+(Hs-Sp),"B2");

// POINTS AT SOLID #

	Vector3D O2_A2 	= *sys.new_Vector3D("O2_A2",-Lp,0.0,-(Sp+Hn),"B2");
	Vector3D A2_Z2	= *sys.new_Vector3D("A2_Z2",+(Lp+Lp),0.0,0.0,"B2");
	Vector3D A2_M2 	= *sys.new_Vector3D("A2_M2",+(Si+Lp),0.0,0.0,"B2");
	Vector3D O3_A3 	= *sys.new_Vector3D("O3_A3",-(Bx+Rx),0.0,0.0,"B3");
	Vector3D O4_Z4 	= *sys.new_Vector3D("O4_Z4",+(Lp+Ln),0.0,0.0,"B4");
	Vector3D O4_M4 	= *sys.new_Vector3D("O4_M4",+(Si+Ln),0.0,0.0,"B4");
	Vector3D O4_D4 	= *sys.new_Vector3D("O4_D4",+(Ss+Ln),0.0,0.0,"B4");
	Vector3D D4_MS4 = *sys.new_Vector3D("D4_MS4",0.0,0.0,+Di,"B4");
	Vector3D O5_A5 	= *sys.new_Vector3D("O5_A5",-(Mx+Rx),0.0,0.0,"B5");
	Vector3D O6_Z6 	= *sys.new_Vector3D("O6_Z6",+(Lp+Ln),0.0,0.0,"B6");
	Vector3D O6_D6 	= *sys.new_Vector3D("O6_D6",+(Ss+Ln),0.0,0.0,"B6");
	Vector3D D6_MS6 = *sys.new_Vector3D("D6_MS6",0.0,0.0,-Ds,"B6");

	Vector3D O3_PG3 = *sys.new_Vector3D("O3_PG3",0.0,0.0,+Rr,"B2");
	Vector3D O5_PG5 = *sys.new_Vector3D("O5_PG5",0.0,0.0,-Rw,"B4");

	Vector3D B2_010 = *sys.new_Vector3D("B2_010",0.0,1.0,0.0,"B2");
	Vector3D B2_001 = *sys.new_Vector3D("B2_001",0.0,0.0,1.0,"B2");

// Points
// ------------------------------------------------------------------------------------------------
	Point * O1 = sys.new_Point("O1","O",&OO_O1);
	Point * O2 = sys.new_Point("O2","O1",&O1_O2);
	Point * O3 = sys.new_Point("O3","O2",&O2_O3);
	Point * O4 = sys.new_Point("O4","O2",&O2_O4);
	Point * O5 = sys.new_Point("O5","O4",&O4_O5);
	Point * O6 = sys.new_Point("O6","O2",&O2_O6);

	Point * A2 = sys.new_Point("A2","O2",&O2_A2);
	Point * M2 = sys.new_Point("M2","A2",&A2_M2);	//Points M2 & M4 Spring assy.
	Point * M4 = sys.new_Point("M4","O4",&O4_M4);
	Point * D4 = sys.new_Point("D4","O4",&O4_D4);
	Point * MS4 = sys.new_Point("MS4","D4",&D4_MS4);	//Points MS4 & MS6 Spring assy.
	Point * D6 = sys.new_Point("D6","O6",&O6_D6);
	Point * MS6 = sys.new_Point("MS6","D6",&D6_MS6);

	Point * PG3 = sys.new_Point("PG3","O3",&O3_PG3);
	Point * PG5 = sys.new_Point("PG5","O5",&O5_PG5);

// Define Frames
// ------------------------------------------------------------------------------------------------
	Frame * R1 = sys.new_Frame("R1","O1","B1");
	Frame * R2 = sys.new_Frame("R2","O2","B2");
	Frame * R3 = sys.new_Frame("R3","O3","B3");
	Frame * R4 = sys.new_Frame("R4","O4","B4");
	Frame * R5 = sys.new_Frame("R5","O5","B5");
	Frame * R6 = sys.new_Frame("R6","O6","B6");

// Absolute position vectors
// ------------------------------------------------------------------------------------------------
//	Vector3D OO_O1 = sys.Position_Vector("O","O1");
	Vector3D OO_O2 = sys.Position_Vector("O","O2");
	Vector3D OO_O3 = sys.Position_Vector("O","O3");
	Vector3D OO_O4 = sys.Position_Vector("O","O4");
	Vector3D OO_O5 = sys.Position_Vector("O","O5");
	Vector3D OO_O6 = sys.Position_Vector("O","O6");

	Vector3D OO_M2 = sys.Position_Vector("O","M2");
	Vector3D OO_M4 = sys.Position_Vector("O","M4");
	Vector3D OO_MS4 = sys.Position_Vector("O","MS4");
	Vector3D OO_MS6 = sys.Position_Vector("O","MS6");

	Vector3D OO_PG3 = sys.Position_Vector("O","PG3");
	Vector3D OO_PG5 = sys.Position_Vector("O","PG5");

	Vector3D MS4_MS6 = sys.Position_Vector("MS4","MS6");
	Vector3D PG3_PG5 = sys.Position_Vector("PG3","PG5");
	
// Absolute vel. & accel.
// ------------------------------------------------------------------------------------------------
	Vector3D VabsO1 = sys.Dt(OO_O1,"abs");
	Vector3D VabsO2 = sys.Dt(OO_O2,"abs");
	Vector3D VabsO3 = sys.Dt(OO_O3,"abs");
	Vector3D VabsO4 = sys.Dt(OO_O4,"abs");
	Vector3D VabsO5 = sys.Dt(OO_O5,"abs");
	Vector3D VabsO6 = sys.Dt(OO_O6,"abs");

	Vector3D AabsO1 = sys.Dt(VabsO1,"abs");
	Vector3D AabsO2 = sys.Dt(VabsO2,"abs");
	Vector3D AabsO3 = sys.Dt(VabsO3,"abs");
	Vector3D AabsO4 = sys.Dt(VabsO4,"abs");
	Vector3D AabsO5 = sys.Dt(VabsO5,"abs");
	Vector3D AabsO6 = sys.Dt(VabsO6,"abs");

// Angular Velocities
// ------------------------------------------------------------------------------------------------
	Vector3D Omega1 = sys.Angular_Velocity("xyz","B1");
	Vector3D Omega2 = sys.Angular_Velocity("xyz","B2");
	Vector3D Omega3 = sys.Angular_Velocity("xyz","B3");
	Vector3D Omega4 = sys.Angular_Velocity("xyz","B4");
	Vector3D Omega5 = sys.Angular_Velocity("xyz","B5");
	Vector3D Omega6 = sys.Angular_Velocity("xyz","B6");

	Vector3D Omega2_3 = sys.Angular_Velocity("B2","B3");
	Vector3D Omega2_5 = sys.Angular_Velocity("B2","B5");

	Vector3D Alfa2_3 = sys.Angular_Acceleration("B2","B3");
	Vector3D Alfa2_5 = sys.Angular_Acceleration("B2","B5");

// Kinematic calculations
// ------------------------------------------------------------------------------------------------
	Vector3D O2_O5 = sys.Position_Vector("O2","O5");

	Vector3D VR2_O3 	= sys.Dt(O2_O3,"B2");
	Vector3D VR2_P3		= VR2_O3 + (Omega2_3 ^ O3_PG3);
	Vector3D VR2_O5 	= sys.Dt(O2_O5,"B2");
	Vector3D VR2_P5 	= VR2_O5 + (Omega2_5 ^ O5_PG5);

	Vector3D AR2_O3 	=	sys.Dt(VR2_O3,"B2");
	Vector3D AR2_P3_n =	(Omega2_3 ^ (Omega2_3 ^ O3_PG3));
	Vector3D AR2_P3_t =	(Alfa2_3 ^ O3_PG3);
	Vector3D AR2_P3		=	AR2_O3 + AR2_P3_n + AR2_P3_t;

	Vector3D AR2_O5 	=	sys.Dt(VR2_O5,"B2");
	Vector3D AR2_P5_n =	(Omega2_5 ^ (Omega2_5 ^ O5_PG5));
	Vector3D AR2_P5_t =	(Alfa2_5 ^ O5_PG5);
	Vector3D AR2_P5		=	AR2_O5 + AR2_P5_n + AR2_P5_t;

	Vector3D VabsM2 	= sys.Dt(OO_M2,"abs");
	Vector3D VabsM4		= sys.Dt(OO_M4,"abs");
	Vector3D VabsMS4		= sys.Dt(OO_MS4,"abs");
	Vector3D VabsMS6		= sys.Dt(OO_MS6,"abs");

	Vector3D VabsPG3	= sys.Dt(OO_PG3,"abs");
	Vector3D VabsPG5	= sys.Dt(OO_PG5,"abs");

	Vector3D VabsP3 	= sys.Dt(OO_O3,"abs") + (Omega3 ^ O3_PG3);
	Vector3D VabsP5 	= sys.Dt(OO_O5,"abs") + (Omega5 ^ O5_PG5);

	Vector3D VrelP3_P5 	= VabsP5 - VabsP3;

// ************************************************************************************************
// DYNAMICS
// ************************************************************************************************

// Dynamical Parameter Definition
// ------------------------------------------------------------------------------------------------
	// Dynamic Parameters of Bar 1
symbol_numeric  m1 = *sys.new_Parameter("m1",9.6676570E-00);
symbol_numeric  mx1 = *sys.new_Parameter("mx1",9.6676570E-00 * (+3.1468184E-04 -	(+0.0000)));
symbol_numeric  my1 = *sys.new_Parameter("my1",9.6676570E-00 * (-4.6322712E-04 -	(+0.0000)));
symbol_numeric  mz1 = *sys.new_Parameter("mz1",9.6676570E-00 * (+3.8007545E-02 -	(+0.0000)) );
symbol_numeric  Ixx1 = *sys.new_Parameter("Ixx1",+9.6622045E-01 + 9.6676570E-00 * (pow((-4.6322712E-04 -	(+0.0000)),2.0)+pow((+3.8007545E-02 -	(+0.0000)),2.0)));
symbol_numeric  Ixy1 = *sys.new_Parameter("Ixy1",-9.6717981E-07 - 9.6676570E-00 * ((+3.1468184E-04 -	(+0.0000))  *(-4.6322712E-04 -	(+0.0000))  ));
symbol_numeric  Ixz1 = *sys.new_Parameter("Ixz1",-1.5818274E-04 - 9.6676570E-00 * ((+3.1468184E-04 -	(+0.0000))  *(+3.8007545E-02 -	(+0.0000))  ));
symbol_numeric  Iyy1 = *sys.new_Parameter("Iyy1",+3.4517226E-01 + 9.6676570E-00 * (pow((+3.1468184E-04 -	(+0.0000)),2.0)+pow((+3.8007545E-02 -	(+0.0000)),2.0)));
symbol_numeric  Iyz1 = *sys.new_Parameter("Iyz1",-1.7021186E-04 - 9.6676570E-00 * ((-4.6322712E-04 -	(+0.0000))  *(+3.8007545E-02 -	(+0.0000))  ));		
symbol_numeric  Izz1 = *sys.new_Parameter("Izz1",+1.2621684E+00 + 9.6676570E-00 * (pow((+3.1468184E-04 -	(+0.0000)),2.0)+pow((-4.6322712E-04 -	(+0.0000)),2.0)));

	// Dynamic Parameters of Bar 2
symbol_numeric  m2 = *sys.new_Parameter("m2",3.9817384E+01);
symbol_numeric  mx2 = *sys.new_Parameter("mx2",3.9817384E+01 * (+7.4441072E-02 -	(+0.0000)));
symbol_numeric  my2 = *sys.new_Parameter("my2",3.9817384E+01 * (+3.2374109E-04 -	(+0.0000)));
symbol_numeric  mz2 = *sys.new_Parameter("mz2",3.9817384E+01 * (-4.4448598E-01 -	(+0.0900)));
symbol_numeric  Ixx2 = *sys.new_Parameter("Ixx2",+3.4371996E+00 + 3.9817384E+01 * (pow((+3.2374109E-04 -	(+0.0000)),2.0)+pow((-4.4448598E-01 -	(+0.0900)),2.0)));
symbol_numeric  Ixy2 = *sys.new_Parameter("Ixy2",+4.9170998E-03 - 3.9817384E+01 * ((+7.4441072E-02 -	(+0.0000))  *(+3.2374109E-04 -	(+0.0000))  ));
symbol_numeric  Ixz2 = *sys.new_Parameter("Ixz2",+4.0363785E-01 - 3.9817384E+01 * ((+7.4441072E-02 -	(+0.0000))  *(-4.4448598E-01 -	(+0.0900))  ));	
symbol_numeric  Iyy2 = *sys.new_Parameter("Iyy2",+6.5136166E+00 + 3.9817384E+01 * (pow((+7.4441072E-02 -	(+0.0000)),2.0)+pow((-4.4448598E-01 -	(+0.0900)),2.0)));
symbol_numeric  Iyz2 = *sys.new_Parameter("Iyz2",-1.6499419E-03 - 3.9817384E+01 * ((+3.2374109E-04 -	(+0.0000))  *(-4.4448598E-01 -	(+0.0900))  ));	
symbol_numeric  Izz2 = *sys.new_Parameter("Izz2",+4.3862389E+00 + 3.9817384E+01 * (pow((+7.4441072E-02 -	(+0.0000)),2.0)+pow((+3.2374109E-04 -	(+0.0000)),2.0)));

	// Dynamic Parameters of Bar 3
symbol_numeric  m3 = *sys.new_Parameter("m3",5.9558960E+00);
symbol_numeric  mx3 = *sys.new_Parameter("mx3",5.9558960E+00 * (+1.4695089E-01 -	(+0.1550)));
symbol_numeric  my3 = *sys.new_Parameter("my3",5.9558960E+00 * (+8.7976133E-06 -	(+0.0000)));
symbol_numeric  mz3 = *sys.new_Parameter("mz3",5.9558960E+00 * (-4.8279441E-01 -	(-0.4825)));
symbol_numeric  Ixx3 = *sys.new_Parameter("Ixx3",+1.0136931E-02 + 5.9558960E+00 * (pow((+8.7976133E-06 -	(+0.0000)),2.0)+pow((-4.8279441E-01 -	(-0.4825)),2.0)));
symbol_numeric  Ixy3 = *sys.new_Parameter("Ixy3",+1.3857334E-05 - 5.9558960E+00 * ((+1.4695089E-01 -	(+0.1550))  *(+8.7976133E-06 -	(+0.0000))  ));
symbol_numeric  Ixz3 = *sys.new_Parameter("Ixz3",-4.2223407E-06 - 5.9558960E+00 * ((+1.4695089E-01 -	(+0.1550))  *(-4.8279441E-01 -	(-0.4825))  ));
symbol_numeric  Iyy3 = *sys.new_Parameter("Iyy3",+8.4531364E-02 + 5.9558960E+00 * (pow((+1.4695089E-01 -	(+0.1550)),2.0)+pow((-4.8279441E-01 -	(-0.4825)),2.0)));
symbol_numeric  Iyz3 = *sys.new_Parameter("Iyz3",+1.3045386E-06 - 5.9558960E+00 * ((+8.7976133E-06 -	(+0.0000))  *(-4.8279441E-01 -	(-0.4825))  ));		
symbol_numeric  Izz3 = *sys.new_Parameter("Izz3",+8.4530535E-02 + 5.9558960E+00 * (pow((+1.4695089E-01 -	(+0.1550)),2.0)+pow((+8.7976133E-06 -	(+0.0000)),2.0)));

	// Dynamic Parameters of Bar 4
symbol_numeric  m4 = *sys.new_Parameter("m4",3.0096650E+01);
symbol_numeric  mx4 = *sys.new_Parameter("mx4",3.0096650E+01 * (-1.1368957E-01 -	(-0.3848)));
symbol_numeric  my4 = *sys.new_Parameter("my4",3.0096650E+01 * (+2.1208222E-02 -	(+0.0000)));
symbol_numeric  mz4 = *sys.new_Parameter("mz4",3.0096650E+01 * (-2.2992162E-01 -	(-0.2626)));
symbol_numeric  Ixx4 = *sys.new_Parameter("Ixx4",+7.3795017E-01 + 3.0096650E+01 * (pow((+2.1208222E-02 -	(+0.0000)),2.0)+pow((-2.2992162E-01 -	(-0.2626)),2.0)));
symbol_numeric  Ixy4 = *sys.new_Parameter("Ixy4",+7.5389739E-02 - 3.0096650E+01 * ((-1.1368957E-01 -	(-0.3848))  *(+2.1208222E-02 -	(+0.0000))  ));
symbol_numeric  Ixz4 = *sys.new_Parameter("Ixz4",+1.0735597E-01 - 3.0096650E+01 * ((-1.1368957E-01 -	(-0.3848))  *(-2.2992162E-01 -	(-0.2626))  ));	
symbol_numeric  Iyy4 = *sys.new_Parameter("Iyy4",+1.9455706E+00 + 3.0096650E+01 * (pow((-1.1368957E-01 -	(-0.3848)),2.0)+pow((-2.2992162E-01 -	(-0.2626)),2.0)));
symbol_numeric  Iyz4 = *sys.new_Parameter("Iyz4",-5.9818181E-02 - 3.0096650E+01 * ((+2.1208222E-02 -	(+0.0000))  *(-2.2992162E-01 -	(-0.2626))  ));	
symbol_numeric  Izz4 = *sys.new_Parameter("Izz4",+1.9115995E+00 + 3.0096650E+01 * (pow((-1.1368957E-01 -	(-0.3848)),2.0)+pow((+2.1208222E-02 -	(+0.0000)),2.0)));

	// Dynamic Parameters of Bar 5
symbol_numeric  m5 = *sys.new_Parameter("m5",5.9935295E+00);
symbol_numeric  mx5 = *sys.new_Parameter("mx5",5.9935295E+00 * (+3.4069777E-02 -	(+0.1550)));
symbol_numeric  my5 = *sys.new_Parameter("my5",5.9935295E+00 * (-8.3998698E-05 -	(+0.0000)));
symbol_numeric  mz5 = *sys.new_Parameter("mz5",5.9935295E+00 * (-3.3219413E-01 -	(-0.3325)));
symbol_numeric  Ixx5 = *sys.new_Parameter("Ixx5",+1.0233319E-02 + 5.9935295E+00 * (pow((-8.3998698E-05 -	(+0.0000)),2.0)+pow((-3.3219413E-01 -	(-0.3325)),2.0)));
symbol_numeric  Ixy5 = *sys.new_Parameter("Ixy5",-1.2319444E-04 - 5.9935295E+00 * ((+3.4069777E-02 -	(+0.1550))  *(-8.3998698E-05 -	(+0.0000))  ));
symbol_numeric  Ixz5 = *sys.new_Parameter("Ixz5",-2.5817770E-07 - 5.9935295E+00 * ((+3.4069777E-02 -	(+0.1550))  *(-3.3219413E-01 -	(-0.3325))  ));	
symbol_numeric  Iyy5 = *sys.new_Parameter("Iyy5",+1.7641985E-01 + 5.9935295E+00 * (pow((+3.4069777E-02 -	(+0.1550)),2.0)+pow((-3.3219413E-01 -	(-0.3325)),2.0)));
symbol_numeric  Iyz5 = *sys.new_Parameter("Iyz5",+1.3534583E-06 - 5.9935295E+00 * ((-8.3998698E-05 -	(+0.0000))  *(-3.3219413E-01 -	(-0.3325))  ));
symbol_numeric  Izz5 = *sys.new_Parameter("Izz5",+1.7641394E-01 + 5.9935295E+00 * (pow((+3.4069777E-02 -	(+0.1550)),2.0)+pow((-8.3998698E-05 -	(+0.0000)),2.0)));

	// Dynamic Parameters of Bar 6
symbol_numeric  m6 = *sys.new_Parameter("m6",1.1543302E+01);
symbol_numeric  mx6 = *sys.new_Parameter("mx6",1.1543302E+01 * (+1.6951865E-03 -	(-0.3848)));
symbol_numeric  my6 = *sys.new_Parameter("my6",1.1543302E+01 * (-0.0000000E+00 -	(+0.0000)));
symbol_numeric  mz6 = *sys.new_Parameter("mz6",1.1543302E+01 * (+1.8654568E-01 -	(+0.2294)));
symbol_numeric  Ixx6 = *sys.new_Parameter("Ixx6",+3.7529484E-01 + 1.1543302E+01 * (pow((-0.0000000E+00 -	(+0.0000)),2.0)+pow((+1.8654568E-01 -	(+0.2294)),2.0)));
symbol_numeric  Ixy6 = *sys.new_Parameter("Ixy6",-0.0000000E+00 - 1.1543302E+01 * ((+1.6951865E-03 -	(-0.3848))  *(-0.0000000E+00 -	(+0.0000))  ));
symbol_numeric  Ixz6 = *sys.new_Parameter("Ixz6",+1.7104997E-01 - 1.1543302E+01 * ((+1.6951865E-03 -	(-0.3848))  *(+1.8654568E-01 -	(+0.2294))  ));	
symbol_numeric  Iyy6 = *sys.new_Parameter("Iyy6",+1.1578711E+00 + 1.1543302E+01 * (pow((+1.6951865E-03 -	(-0.3848)),2.0)+pow((+1.8654568E-01 -	(+0.2294)),2.0)));
symbol_numeric  Iyz6 = *sys.new_Parameter("Iyz6",-0.0000000E+00 - 1.1543302E+01 * ((-0.0000000E+00 -	(+0.0000))  *(+1.8654568E-01 -	(+0.2294))  ));	
symbol_numeric  Izz6 = *sys.new_Parameter("Izz6",+1.3162802E+00 + 1.1543302E+01 * (pow((+1.6951865E-03 -	(-0.3848)),2.0)+pow((-0.0000000E+00 -	(+0.0000)),2.0)));

// Inertia Tensor Definition
// ------------------------------------------------------------------------------------------------
	// Inertia Tensor of Bar 1
	Tensor3D  I1_O1 = *sys.new_Tensor3D("I1_O1",	(ex)Ixx1,	(ex)Ixy1,	(ex)Ixz1,
																								(ex)Ixy1,	(ex)Iyy1,	(ex)Iyz1,
																								(ex)Ixz1,	(ex)Iyz1,	(ex)Izz1,	"B1");

	// Inertia Tensor of Bar 2
	Tensor3D  I2_O2 = *sys.new_Tensor3D("I2_O2",	(ex)Ixx2,	(ex)Ixy2,	(ex)Ixz2,
																								(ex)Ixy2,	(ex)Iyy2,	(ex)Iyz2,
																								(ex)Ixz2,	(ex)Iyz2,	(ex)Izz2,	"B2");

	// Inertia Tensor of Bar 3
	Tensor3D  I3_O3 = *sys.new_Tensor3D("I3_O3",	(ex)Ixx3,	(ex)Ixy3,	(ex)Ixz3,
																								(ex)Ixy3,	(ex)Iyy3,	(ex)Iyz3,
																								(ex)Ixz3,	(ex)Iyz3,	(ex)Izz3,	"B3");

	// Inertia Tensor of Bar 4
	Tensor3D  I4_O4 = *sys.new_Tensor3D("I4_O4",	(ex)Ixx4,	(ex)Ixy4,	(ex)Ixz4,
																								(ex)Ixy4,	(ex)Iyy4,	(ex)Iyz4,
																								(ex)Ixz4,	(ex)Iyz4,	(ex)Izz4,	"B4");

	// Inertia Tensor of Bar 5
	Tensor3D  I5_O5 = *sys.new_Tensor3D("I5_O5",	(ex)Ixx5,	(ex)Ixy5,	(ex)Ixz5,
																								(ex)Ixy5,	(ex)Iyy5,	(ex)Iyz5,
																								(ex)Ixz5,	(ex)Iyz5,	(ex)Izz5,	"B5");

	// Inertia Tensor of Bar 6
	Tensor3D  I6_O6 = *sys.new_Tensor3D("I6_O6",	(ex)Ixx6,	(ex)Ixy6,	(ex)Ixz6,
																								(ex)Ixy6,	(ex)Iyy6,	(ex)Iyz6,
																								(ex)Ixz6,	(ex)Iyz6,	(ex)Izz6,	"B6");

// Center of Gravity Points Definition
// ------------------------------------------------------------------------------------------------
	// Vectors
	Vector3D O1_G1 = *sys.new_Vector3D("O1_G1",mx1/m1,my1/m1,mz1/m1,"B1");
	Vector3D O2_G2 = *sys.new_Vector3D("O2_G2",mx2/m2,my2/m2,mz2/m2,"B2");
	Vector3D O3_G3 = *sys.new_Vector3D("O3_G3",mx3/m3,my3/m3,mz3/m3,"B3");
	Vector3D O4_G4 = *sys.new_Vector3D("O4_G4",mx4/m4,my4/m4,mz4/m4,"B4");
	Vector3D O5_G5 = *sys.new_Vector3D("O5_G5",mx5/m5,my5/m5,mz5/m5,"B5");
	Vector3D O6_G6 = *sys.new_Vector3D("O6_G6",mx6/m6,my6/m6,mz6/m6,"B6");

	// Points
	Point * G1 = sys.new_Point("G1","O1",&O1_G1);
	Point * G2 = sys.new_Point("G2","O2",&O2_G2);
	Point * G3 = sys.new_Point("G3","O3",&O3_G3);
	Point * G4 = sys.new_Point("G4","O4",&O4_G4);
	Point * G5 = sys.new_Point("G5","O5",&O5_G5);
	Point * G6 = sys.new_Point("G6","O6",&O6_G6);

	// Absolute position Vector of G
	Vector3D OO_G1 = sys.Position_Vector("O","G1");
	Vector3D OO_G2 = sys.Position_Vector("O","G2");
	Vector3D OO_G3 = sys.Position_Vector("O","G3");
	Vector3D OO_G4 = sys.Position_Vector("O","G4");
	Vector3D OO_G5 = sys.Position_Vector("O","G5");
	Vector3D OO_G6 = sys.Position_Vector("O","G6");

	// Define Velocity and Acceleration of Center of Gravity Points
	Vector3D VabsG1 = sys.Dt(OO_G1,"abs");
	Vector3D AabsG1 = sys.Dt(VabsG1,"abs");

	Vector3D VabsG2 = sys.Dt(OO_G2,"abs");
	Vector3D AabsG2 = sys.Dt(VabsG2,"abs");

	Vector3D VabsG3 = sys.Dt(OO_G3,"abs");
	Vector3D AabsG3 = sys.Dt(VabsG3,"abs");

	Vector3D VabsG4 = sys.Dt(OO_G4,"abs");
	Vector3D AabsG4 = sys.Dt(VabsG4,"abs");

	Vector3D VabsG5 = sys.Dt(OO_G5,"abs");
	Vector3D AabsG5 = sys.Dt(VabsG5,"abs");

	Vector3D VabsG6 = sys.Dt(OO_G6,"abs");
	Vector3D AabsG6 = sys.Dt(VabsG6,"abs");


//*************************************************************************************************
//*************************************************************************************************
//#define SLIP // Comment this line for Non_Slip conditions
//*************************************************************************************************
//*************************************************************************************************
#ifdef SLIP

cout << "SLIP defined" << endl;

	#ifdef LAG
		symbol_numeric lambda1		= *sys.new_Joint_Unknown("lambda1",0.0);

		cout << "" << endl;
		cout << "Option not defined. Lagangre and Slip not available." << endl;
		cout << "" << endl;
	return 0;
// to define this option V*Fe=Phi_qT*lambda. Then include in din eq.

	#endif
	#ifdef V_P
		// Joint Unknown Definition
		// Contact forces between solid 3 and 5. Defined Actuating on solid 3.
		symbol_numeric Fn 				= *sys.new_Joint_Unknown("Fn");
		Vector3D F_E_53 	= *sys.new_Vector3D("F_E_53",0,0,-Fn,"B2");	// Torsor.
		// Tang. Force. Defined actuating on solid 3.
		ex VR 						= (VrelP3_P5 * B2_010);

		symbol_numeric mu								= *sys.new_Parameter("mu"		,0.1000);
		symbol_numeric grad_V0_mu				= *sys.new_Parameter("grad"	,5.0000);
		ex     V0	= mu / grad_V0_mu;	// gradient not too steep or integration problems

		ex Ft 						= (step(VR - V0) - (1 - step(VR + V0))) * (mu * Fn) + (step(VR + V0) - step(VR - V0)) * (mu * Fn * (VR / V0));
		Vector3D F_T_53 	= *sys.new_Vector3D("F_T_53",0,Ft,0,"B2");	// Torsor.
	#endif

	// ************************************************************************************************
	// KINEMATIC EQUATIONS
	// ************************************************************************************************
	ex constr_eq_set_1 = PG3_PG5 * B2_001;	// Solo condicion de contacto

	Matrix Phi(1,1,&constr_eq_set_1);
	Matrix Zero(1,1);		// joint unkonws x joint unkonws

#else

cout << "NO SLIP defined" << endl;

	#ifdef LAG
		symbol_numeric lambda1	= *sys.new_Joint_Unknown("lambda1",0.0);
		symbol_numeric lambda2	= *sys.new_Joint_Unknown("lambda2",0.0);
	#endif
	#ifdef V_P
		// Joint Unknown Definition
		// Contact forces between solid 3 and 5. Defined Actuating on solid 3.
	symbol_numeric  Fn 			= *sys.new_Joint_Unknown("Fn");
	symbol_numeric  Ft 			= *sys.new_Joint_Unknown("Ft");
		Vector3D F_E_53 = *sys.new_Vector3D("F_E_53",0,Ft,Fn,"B2");	// Torsor.
		// Tang. Force. Defined actuating on solid 3.
		Vector3D F_T_53 	= *sys.new_Vector3D("F_T_53",0,0,0,"B2");	// Torsor.
	#endif

	// ************************************************************************************************
	// KINEMATIC EQUATIONS
	// ************************************************************************************************
	ex constr_eq_set_1 = PG3_PG5 * B2_001;	// Condicion de contacto
	ex constr_eq_set_2 = -q3*Rr-q5*Rw;			// Condicion de no deliz.

	Matrix Phi(2,1,&constr_eq_set_1,&constr_eq_set_2);
	Matrix Zero(2,2);		// joint unkonws x joint unkonws

#endif
// ************************************************************************************************
// ************************************************************************************************


// ------------------------------------------------------------------------------------------------
// EXTERNAL FORCES-TORQUES APPLIED TO THE HUB
// ------------------------------------------------------------------------------------------------
	symbol_numeric Tm 		= *sys.new_Input("Tm",0.0); // Tm pos if q5 pos on axis 1 B5. Defined actuating on 5.
	symbol_numeric Tb 		= *sys.new_Input("Tb",0.0);	// Tb pos if q3 pos on axis 1 B3. Defined actuating on 3.


// Constitutive Forces and moments Definition
// ------------------------------------------------------------------------------------------------
	// External forces and moments
// Fc pos if spring pushing wheel against road. Defined actuating on 2.
	ex Fc 						=	+Ks*(Ls0-Ls)-Ki*(Li0-Li);
	Vector3D F_spring	= *sys.new_Vector3D("F_spring",0,0,Fc,"B2");

// Fs pos if pushing mass upwards. Defined actuating on 6.
	ex			LL				= pow((MS4_MS6 * MS4_MS6),0.5);	// F on spring function of position of spring endings.
	Vector3D F_susp		= (K*(L0-LL)/LL) * (MS4_MS6);		// F on spring diretion of spring.

// Motor and brake
	Vector3D T_motor	= *sys.new_Vector3D("T_motor",Tm,0,0,"B5");
	Vector3D T_brake	= *sys.new_Vector3D("T_brake",Tb,0,0,"B3");

	// Gravity vectors
	Vector3D F_G_1 = *sys.new_Vector3D("F_G_1",0,0,-m1 * (*g),"xyz");
	Vector3D F_G_2 = *sys.new_Vector3D("F_G_2",0,0,-m2 * (*g),"xyz");
	Vector3D F_G_3 = *sys.new_Vector3D("F_G_3",0,0,-m3 * (*g),"xyz");
	Vector3D F_G_4 = *sys.new_Vector3D("F_G_4",0,0,-m4 * (*g),"xyz");
	Vector3D F_G_5 = *sys.new_Vector3D("F_G_5",0,0,-m5 * (*g),"xyz");
	Vector3D F_G_6 = *sys.new_Vector3D("F_G_6",0,0,-m6 * (*g),"xyz");

	// Inertia Forces
	Vector3D F_I_O1 = -m1 * AabsG1;
	Vector3D F_I_O2 = -m2 * AabsG2;
	Vector3D F_I_O3 = -m3 * AabsG3;
	Vector3D F_I_O4 = -m4 * AabsG4;
	Vector3D F_I_O5 = -m5 * AabsG5;
	Vector3D F_I_O6 = -m6 * AabsG6;

	// Angular moment and Inertia Moment
	Vector3D H1_O1 = I1_O1 * Omega1;
	Vector3D H2_O2 = I2_O2 * Omega2;
	Vector3D H3_O3 = I3_O3 * Omega3;
	Vector3D H4_O4 = I4_O4 * Omega4;
	Vector3D H5_O5 = I5_O5 * Omega5;
	Vector3D H6_O6 = I6_O6 * Omega6;

	Vector3D M_I_O1 = -sys.Dt(H1_O1,"xyz") - ((m1 * O1_G1) ^ AabsO1);
	Vector3D M_I_O2 = -sys.Dt(H2_O2,"xyz") - ((m2 * O2_G2) ^ AabsO2);
	Vector3D M_I_O3 = -sys.Dt(H3_O3,"xyz") - ((m3 * O3_G3) ^ AabsO3);
	Vector3D M_I_O4 = -sys.Dt(H4_O4,"xyz") - ((m4 * O4_G4) ^ AabsO4);
	Vector3D M_I_O5 = -sys.Dt(H5_O5,"xyz") - ((m5 * O5_G5) ^ AabsO5);
	Vector3D M_I_O6 = -sys.Dt(H6_O6,"xyz") - ((m6 * O6_G6) ^ AabsO6);

// ************************************************************************************************
// DYNAMIC EQUATIONS
// ************************************************************************************************

cout << "Dynamic Equations" << endl;

//	Matrix q					= sys.Coordinates();
//	Matrix dq 				= sys.Velocities();
//	Matrix ddq 				= sys.Accelerations();

	Matrix parameters	= sys.Parameters();
	Matrix input 			= sys.Inputs();




// Coordinates and parameters
// ------------------------------------------------------------------------------------------------

  vector < symbol_numeric * > Coordinates 		= sys.get_Coordinates();
  vector < symbol_numeric * > Velocities 			= sys.get_Velocities();
  vector < symbol_numeric * > Accelerations		= sys.get_Accelerations();
  vector < symbol_numeric * > Joint_Unknowns 	= sys.get_Joint_Unknowns();
  vector < symbol_numeric * > Parameters 			= sys.get_Parameters();
  vector < symbol_numeric * > Inputs		 			= sys.get_Inputs();

	symbol_numeric *dq1=sys.get_Velocity("dq1");
	symbol_numeric *dq2=sys.get_Velocity("dq2");
	symbol_numeric *dq3=sys.get_Velocity("dq3");
	symbol_numeric *dq4=sys.get_Velocity("dq4");
	symbol_numeric *dq5=sys.get_Velocity("dq5");
	symbol_numeric *dq6=sys.get_Velocity("dq6");

	symbol_numeric *ddq1=sys.get_Acceleration("ddq1");
	symbol_numeric *ddq2=sys.get_Acceleration("ddq2");
	symbol_numeric *ddq3=sys.get_Acceleration("ddq3");
	symbol_numeric *ddq4=sys.get_Acceleration("ddq4");
	symbol_numeric *ddq5=sys.get_Acceleration("ddq5");
	symbol_numeric *ddq6=sys.get_Acceleration("ddq6");

#ifdef SLIP

lst coord_indep;
lst vel_indep;
lst accel_indep;

coord_indep	= q1,q2,q3,q5,q6;
vel_indep		= *dq1,*dq2,*dq3,*dq5,*dq6;
accel_indep	= *ddq1,*ddq2,*ddq3,*ddq5,*ddq6;

Matrix q_indep		((Coordinates.size()-Phi.rows()),1, coord_indep);
Matrix dq_indep		((Coordinates.size()-Phi.rows()),1,	vel_indep);
Matrix ddq_indep	((Coordinates.size()-Phi.rows()),1,	accel_indep);

lst coord_dep;
lst vel_dep;
lst accel_dep;

coord_dep	= q4;
vel_dep		= *dq4;
accel_dep	= *ddq4;

Matrix q_dep			(Phi.rows(),1, coord_dep);
Matrix dq_dep			(Phi.rows(),1, vel_dep);
Matrix ddq_dep		(Phi.rows(),1, accel_dep);

// Initial conditions. Pos-Vel. Forwards Kinematics.
// ------------------------------------------------------------------------------------------------
symbol_numeric q1_0		= *sys.new_Parameter("q1_0"		,0.0);
symbol_numeric q2_0		= *sys.new_Parameter("q2_0"		,0.0);
symbol_numeric q3_0		= *sys.new_Parameter("q3_0"		,0.0);
symbol_numeric q5_0		= *sys.new_Parameter("q5_0"		,0.0);
symbol_numeric q6_0		= *sys.new_Parameter("q6_0"		,0.0);

symbol_numeric dq1_0		= *sys.new_Parameter("dq1_0"		,0.0);
symbol_numeric dq2_0		= *sys.new_Parameter("dq2_0"		,0.0);
symbol_numeric dq3_0		= *sys.new_Parameter("dq3_0"		,0.0);
symbol_numeric dq5_0		= *sys.new_Parameter("dq5_0"		,0.0);
symbol_numeric dq6_0		= *sys.new_Parameter("dq6_0"		,0.0);

Matrix Init				(5,1	,lst((q1-q1_0),(q2-q2_0),(q3-q3_0),(q5-q5_0),(q6-q6_0)));
Matrix Init_t			(5,1	,lst(-dq1_0,-dq2_0,-dq3_0,-dq5_0,-dq6_0));
Matrix PhiInit		(2,1	,&Phi,&Init);

#else

lst coord_indep;
lst vel_indep;
lst accel_indep;

coord_indep	= q1,q2,q5,q6;
vel_indep		= *dq1,*dq2,*dq5,*dq6;
accel_indep	= *ddq1,*ddq2,*ddq5,*ddq6;

Matrix q_indep		((Coordinates.size()-Phi.rows()),1, coord_indep);
Matrix dq_indep		((Coordinates.size()-Phi.rows()),1,	vel_indep);
Matrix ddq_indep	((Coordinates.size()-Phi.rows()),1,	accel_indep);

lst coord_dep;
lst vel_dep;
lst accel_dep;

coord_dep	= q3,q4;
vel_dep		= *dq3,*dq4;
accel_dep	= *ddq3,*ddq4;

Matrix q_dep			(Phi.rows(),1, coord_dep);
Matrix dq_dep			(Phi.rows(),1, vel_dep);
Matrix ddq_dep		(Phi.rows(),1, accel_dep);

// Initial conditions. Pos-Vel. Forwards Kinematics.
// ------------------------------------------------------------------------------------------------
symbol_numeric q1_0		= *sys.new_Parameter("q1_0"		,0.0);
symbol_numeric q2_0		= *sys.new_Parameter("q2_0"		,0.0);
symbol_numeric q5_0		= *sys.new_Parameter("q5_0"		,0.0);
symbol_numeric q6_0		= *sys.new_Parameter("q6_0"		,0.0);

symbol_numeric dq1_0		= *sys.new_Parameter("dq1_0"		,0.0);
symbol_numeric dq2_0		= *sys.new_Parameter("dq2_0"		,0.0);
symbol_numeric dq5_0		= *sys.new_Parameter("dq5_0"		,0.0);
symbol_numeric dq6_0		= *sys.new_Parameter("dq6_0"		,0.0);


Matrix Init				(4,1	,lst((q1-q1_0),(q2-q2_0),(q5-q5_0),(q6-q6_0)));
Matrix Init_t			(4,1	,lst(-dq1_0,-dq2_0,-dq5_0,-dq6_0));
Matrix PhiInit		(2,1	,&Phi,&Init);

#endif
	Matrix q	(2,1,&q_indep,	&q_dep	);
	Matrix dq	(2,1,&dq_indep,	&dq_dep	);
	Matrix ddq(2,1,&ddq_indep,&ddq_dep);


// Dynamic Equations
// ------------------------------------------------------------------------------------------------

Matrix Dynamic_Equations_z_open(dq_indep.rows(),1);	// As many dyn.eq. as indep.coordinates 

for (int i=0; (i < dq_indep.rows()); ++i) {
 symbol_numeric dq_indep_i;
 dq_indep_i=ex_to<symbol_numeric>(dq_indep(i,0));
 Dynamic_Equations_z_open (i,0) = 
// 	Inertial Forces and Torques
	  F_I_O1 * sys.diff(VabsO1,dq_indep_i) + M_I_O1 * sys.diff(Omega1,dq_indep_i)
	+ F_I_O2 * sys.diff(VabsO2,dq_indep_i) + M_I_O2 * sys.diff(Omega2,dq_indep_i)
	+ F_I_O3 * sys.diff(VabsO3,dq_indep_i) + M_I_O3 * sys.diff(Omega3,dq_indep_i)
	+ F_I_O4 * sys.diff(VabsO4,dq_indep_i) + M_I_O4 * sys.diff(Omega4,dq_indep_i)
	+ F_I_O5 * sys.diff(VabsO5,dq_indep_i) + M_I_O5 * sys.diff(Omega5,dq_indep_i)
	+ F_I_O6 * sys.diff(VabsO6,dq_indep_i) + M_I_O6 * sys.diff(Omega6,dq_indep_i)

// 	Gravitational Forces
	+ F_G_1 * sys.diff(VabsG1,dq_indep_i)
	+ F_G_2 * sys.diff(VabsG2,dq_indep_i)
	+ F_G_3 * sys.diff(VabsG3,dq_indep_i)
	+ F_G_4 * sys.diff(VabsG4,dq_indep_i)
	+ F_G_5 * sys.diff(VabsG5,dq_indep_i)
	+ F_G_6 * sys.diff(VabsG6,dq_indep_i)

// 	Constitutive Forces and Torques
	+ F_spring * sys.diff(VabsM2,dq_indep_i) - F_spring * sys.diff(VabsM4,dq_indep_i)
	+ F_susp * sys.diff(VabsMS6,dq_indep_i) - F_susp * sys.diff(VabsMS4,dq_indep_i)
	+ T_motor * sys.diff(Omega5,dq_indep_i)	- T_motor * sys.diff(Omega4,dq_indep_i)
	+ T_brake * sys.diff(Omega3,dq_indep_i)	- T_brake * sys.diff(Omega2,dq_indep_i)
	;
}

// Dynamic Equations
// ------------------------------------------------------------------------------------------------

Matrix Dynamic_Equations_d_open(dq_dep.rows(),1);	// As many dyn.eq. as dep.coordinates 

for (int i=0; (i < dq_dep.rows()); ++i) {
 symbol_numeric dq_dep_i;
 dq_dep_i=ex_to<symbol_numeric>(dq_dep(i,0));
 Dynamic_Equations_d_open (i,0) = 
// 	Inertial Forces and Torques
	  F_I_O1 * sys.diff(VabsO1,dq_dep_i) + M_I_O1 * sys.diff(Omega1,dq_dep_i)
	+ F_I_O2 * sys.diff(VabsO2,dq_dep_i) + M_I_O2 * sys.diff(Omega2,dq_dep_i)
	+ F_I_O3 * sys.diff(VabsO3,dq_dep_i) + M_I_O3 * sys.diff(Omega3,dq_dep_i)
	+ F_I_O4 * sys.diff(VabsO4,dq_dep_i) + M_I_O4 * sys.diff(Omega4,dq_dep_i)
	+ F_I_O5 * sys.diff(VabsO5,dq_dep_i) + M_I_O5 * sys.diff(Omega5,dq_dep_i)
	+ F_I_O6 * sys.diff(VabsO6,dq_dep_i) + M_I_O6 * sys.diff(Omega6,dq_dep_i)

// 	Gravitational Forces
	+ F_G_1 * sys.diff(VabsG1,dq_dep_i)
	+ F_G_2 * sys.diff(VabsG2,dq_dep_i)
	+ F_G_3 * sys.diff(VabsG3,dq_dep_i)
	+ F_G_4 * sys.diff(VabsG4,dq_dep_i)
	+ F_G_5 * sys.diff(VabsG5,dq_dep_i)
	+ F_G_6 * sys.diff(VabsG6,dq_dep_i)

// 	Constitutive Forces and Torques
	+ F_spring * sys.diff(VabsM2,dq_dep_i) - F_spring * sys.diff(VabsM4,dq_dep_i)
	+ F_susp * sys.diff(VabsMS6,dq_dep_i) - F_susp * sys.diff(VabsMS4,dq_dep_i)
	+ T_motor * sys.diff(Omega5,dq_dep_i)	- T_motor * sys.diff(Omega4,dq_dep_i)
	+ T_brake * sys.diff(Omega3,dq_dep_i)	- T_brake * sys.diff(Omega2,dq_dep_i)
	;
}

// Dynamic Equations
// ------------------------------------------------------------------------------------------------

Matrix Dynamic_Equations_open(dq.rows(),1);	// As many dyn.eq. as gen.coordinates (q1...q6 here)  

for (int i=0; (i < dq.rows()); ++i) {
 symbol_numeric dq_i;
 dq_i=ex_to<symbol_numeric>(dq(i,0));
 Dynamic_Equations_open (i,0) = 
// 	Inertial Forces and Torques
	  F_I_O1 * sys.diff(VabsO1,dq_i) + M_I_O1 * sys.diff(Omega1,dq_i)
	+ F_I_O2 * sys.diff(VabsO2,dq_i) + M_I_O2 * sys.diff(Omega2,dq_i)
	+ F_I_O3 * sys.diff(VabsO3,dq_i) + M_I_O3 * sys.diff(Omega3,dq_i)
	+ F_I_O4 * sys.diff(VabsO4,dq_i) + M_I_O4 * sys.diff(Omega4,dq_i)
	+ F_I_O5 * sys.diff(VabsO5,dq_i) + M_I_O5 * sys.diff(Omega5,dq_i)
	+ F_I_O6 * sys.diff(VabsO6,dq_i) + M_I_O6 * sys.diff(Omega6,dq_i)

// 	Gravitational Forces
	+ F_G_1 * sys.diff(VabsG1,dq_i)
	+ F_G_2 * sys.diff(VabsG2,dq_i)
	+ F_G_3 * sys.diff(VabsG3,dq_i)
	+ F_G_4 * sys.diff(VabsG4,dq_i)
	+ F_G_5 * sys.diff(VabsG5,dq_i)
	+ F_G_6 * sys.diff(VabsG6,dq_i)

// 	Constitutive Forces and Torques
	+ F_spring * sys.diff(VabsM2,dq_i) - F_spring * sys.diff(VabsM4,dq_i)
	+ F_susp * sys.diff(VabsMS6,dq_i) - F_susp * sys.diff(VabsMS4,dq_i)
	+ T_motor * sys.diff(Omega5,dq_i)	- T_motor * sys.diff(Omega4,dq_i)
	+ T_brake * sys.diff(Omega3,dq_i)	- T_brake * sys.diff(Omega2,dq_i)
	;
}

#ifdef V_P

Matrix epsilon 		= sys.Joint_Unknowns();

Matrix Dynamic_Equations(6,1);	// As many dyn.eq. as gen.coordinates (q1...q6 here)  

for (int i=0; (i < dq.rows()); ++i) {
 symbol_numeric dq_i;
 dq_i=ex_to<symbol_numeric>(dq(i,0));
 Dynamic_Equations (i,0) = 
// 	Inertial Forces and Torques
	   Dynamic_Equations_open (i,0)

// 	Joint Forces
	+ F_E_53 * sys.diff(VabsP3,dq_i) - F_E_53 * sys.diff(VabsP5,dq_i)
	+ F_T_53 * sys.diff(VabsP3,dq_i) - F_T_53 * sys.diff(VabsP5,dq_i)
	;
/*
Closed dyn eq in Lagrange solution would be....
	+ lambda1 * Phi_q(0,i)
	+ lambda1 * Phi_q(1,i)
*/
}
Dynamic_Equations 			= - Dynamic_Equations;			//So that MASS matrix will be positive definite as is standard practice.
#endif

Dynamic_Equations_open 	= - Dynamic_Equations_open;	//So that MASS matrix will be positive definite as is standard practice.

// ************************************************************************************************
// Output Vector
// ************************************************************************************************

    cout << "Output Vector" << endl;
    Vector3D ez = *sys.new_Vector3D("ez",0,0,1,"xyz");

    ex Total_Energy =

        // Kinetic and Potential energy
        // ----------------------------
	      + numeric(1,2)*m1*(VabsG1*VabsG1) + numeric(1,2)* Omega1*(H1_O1-m1*(O1_G1^(Omega1^O1_G1))) + m1*(*g)*OO_G1*ez
        + numeric(1,2)*m2*(VabsG2*VabsG2) + numeric(1,2)* Omega2*(H2_O2-m2*(O2_G2^(Omega2^O2_G2))) + m2*(*g)*OO_G2*ez
        + numeric(1,2)*m3*(VabsG3*VabsG3) + numeric(1,2)* Omega3*(H3_O3-m3*(O3_G3^(Omega3^O3_G3))) + m3*(*g)*OO_G3*ez
        + numeric(1,2)*m4*(VabsG4*VabsG4) + numeric(1,2)* Omega4*(H4_O4-m4*(O4_G4^(Omega4^O4_G4))) + m4*(*g)*OO_G4*ez
        + numeric(1,2)*m5*(VabsG5*VabsG5) + numeric(1,2)* Omega5*(H5_O5-m5*(O5_G5^(Omega5^O5_G5))) + m5*(*g)*OO_G5*ez
        + numeric(1,2)*m6*(VabsG6*VabsG6) + numeric(1,2)* Omega6*(H6_O6-m6*(O6_G6^(Omega6^O6_G6))) + m6*(*g)*OO_G6*ez

        // Elastic potential energy
        // ------------------------
        + numeric(1,2)*K*((L0-LL)*(L0-LL))
        ;


//    vector < symbol_numeric * > Coordinates = sys.get_Coordinates();
//    vector < symbol_numeric * > Velocities = sys.get_Velocities();
//    vector < symbol_numeric * > Accelerations = sys.get_Accelerations();
//    vector < symbol_numeric * > Joint_Unknowns = sys.get_Joint_Unknowns();

    Matrix Output(Coordinates.size()+Velocities.size()+Joint_Unknowns.size()+1,1);
    for (int i=0; (i < Coordinates.size()); ++i){
        Output(i,0)=*Coordinates[i];
        }

    for (int i=0; (i < Velocities.size()); ++i){
        Output(Coordinates.size()+i,0)=*Velocities[i];
        }

    for (int i=0; (i < Joint_Unknowns.size()); ++i){
        Output(Coordinates.size()+Velocities.size()+i,0)=*Joint_Unknowns[i];
        }

    Output(Coordinates.size()+Velocities.size()+Joint_Unknowns.size(),0) = Total_Energy; //Total_Energy

Matrix Energy(1,1,&Total_Energy );

// ************************************************************************************************
// MATRIX CALCULATION
// ************************************************************************************************
cout << "Matrix Calculation" << endl;

// General

	Matrix dPhi					=  sys.Dt(Phi);
	Matrix ddPhi				=  sys.Dt(dPhi);
	Matrix Phi_q				=  sys.jacobian(Phi.transpose()	,q);
	Matrix Phi_t				=  sys.jacobian(Phi.transpose()	,sys.get_Time_Symbol());
	Matrix dPhi_q				=  sys.Dt(Phi_q);
	Matrix dPhi_t				=  sys.Dt(Phi_t);

	Matrix PhiInit_t		(2,1,&Phi_t,&Init_t);   //	Matrix PhiInit_t=-sys.jacobian(PhiInit.transpose(),sys.get_Time_Symbol());
	Matrix minus_Phi_t		=-Phi_t;
	Matrix minus_PhiInit_t		=-PhiInit_t;

	Matrix PhiInit_q		= sys.jacobian(PhiInit.transpose()		,q);
	Matrix dPhiInit			= sys.Dt(PhiInit);

	// Above	==>	dPhi	= Phi_q * dq + Phi_t
	// -Phi_t es directamente el termino independiente de velocidades.
	//				==>	ddPhi	= Phi_q * ddq + dPhi_q * dq + dPhi_t
	// -ddPhi cuando ddq=0 es el termino independiente de aceleraciones.
	// gamma es el termino independiente de aceleraciones gamma = - dPhi_q * dq - dPhi_t = Phi_q * ddq - ddPhi

symbol_numeric *ddq_j;
Matrix gamma				=  - ddPhi + Phi_q * ddq;
for (int i=0; (i < gamma.rows()); ++i) {
	for (int j=0; (j < Accelerations.size()); ++j) {
		ddq_j=Accelerations[j];
		gamma(i,0)=gamma(i,0).subs((*ddq_j)==0);
	}
}

/*
	Matrix DEt=Dynamic_Equations_open.transpose();
	symbol_numeric *dq_j;

	for (int i=0; (i < DEt.cols()); ++i) {
	for (int j=0; (j < Velocities.size()); ++j) {
 	               dq_j=Velocities[j];
     	       DEt(0,i)=DEt(0,i).subs((*dq_j)==0);
      	}
        }

	Matrix M ( DEt.cols () , ddq.rows () );     
		if ( ( DEt.rows () == 1 ) and ( ddq.cols () == 1 ) ) {
            		for ( int i = 0 ; i <  DEt.cols () ; i++ )
                	for ( int j = 0; j< ddq.rows () ; j++ ) {
			cout <<i << "," << j << endl;
                        M ( i , j ) =  DEt ( 0 , i ).diff ( ex_to<symbol_numeric> (  ddq ( j , 0 )  ) );}
		}
*/

	Matrix M	= sys.jacobian(Dynamic_Equations_open.transpose()	,ddq);
	Matrix Q	 = -(Dynamic_Equations_open - M*ddq);
	// Above	==>	Dynamic_Equations_open	= M * ddq - Q = 0

for (int i=0; (i < Q.rows()); ++i) {
	for (int j=0; (j < Accelerations.size()); ++j) {
		ddq_j=Accelerations[j];
		Q(i,0)=Q(i,0).subs((*ddq_j)==0);
	}
}

Matrix Qgamma(2,1,&Q,&gamma);

#ifdef LAG		// Esta variable se pasa en la linea de complilacion de main_train_proto.cc
									// Mirar make_all.bash para ver como pasar la variable.

cout << "LAGRANGE PRINCIPLE defined" << endl;

	Matrix Phi_qT				=  Phi_q.transpose();
	Matrix MPhi_qTPhi_qZero(2,2,&M,&Phi_qT,&Phi_q,&Zero);
	Matrix MXPhi_qZero = MPhi_qTPhi_qZero;
#endif

#ifdef V_P

cout << "SYSTEMATIZED VIRTUAL POWER PRINCIPLE defined" << endl;

	Matrix V	= sys.jacobian(Dynamic_Equations.transpose()			,epsilon);
	// Above	==>	Dynamic_Equations				= M * ddq + V * epsilon - Q = 0
	// Tambien OK ==> Matrix Q = -(Dynamic_Equations-(M*ddq+V*epsilon));
	Matrix MVPhi_qZero(2,2,&M,&V,&Phi_q,&Zero);
	Matrix MXPhi_qZero = MVPhi_qZero;

#endif

	Matrix Phi_z				= sys.jacobian(Phi.transpose()	,q_indep);
	Matrix Phi_d				= sys.jacobian(Phi.transpose()	,q_dep);

	Matrix M_zz		= sys.jacobian(Dynamic_Equations_z_open.transpose()	,ddq_indep);
	Matrix M_zd		= sys.jacobian(Dynamic_Equations_z_open.transpose()	,ddq_dep);
	Matrix M_dd		= sys.jacobian(Dynamic_Equations_d_open.transpose()	,ddq_dep);

	Matrix Q_z		= -(Dynamic_Equations_z_open - M_zz * ddq_indep - M_zd * ddq_dep);
	Matrix Q_d		= -(Dynamic_Equations_d_open - M_zd.transpose() * ddq_indep - M_dd * ddq_dep);

// ************************************************************************************************
// ************************************************************************************************
// ************************************************************************************************
//Begin Javier
ofstream matlab_file;

  matlab_file.open ("param_init.m");
  for ( int i = 0 ; i < Parameters.size () ; i++ )
        matlab_file << "global " << Parameters[i]-> get_name () << ";" << endl;
  for ( int i = 0 ; i < Parameters.size () ; i++ )
        matlab_file << Parameters[i]-> get_name () << " = " << Parameters[i]-> get_value () << ";" << endl;
  matlab_file.close();

  matlab_file.open ("param_vect_init.m");
  for ( int i = 0 ; i < Parameters.size () ; i++ )
        matlab_file << "global " << Parameters[i]-> get_name () << ";" << endl;
  matlab_file << "global param;" << endl;
  matlab_file << "param=[" ;
  for ( int i = 0 ; i < Parameters.size ()-1 ; i++ )
        matlab_file << Parameters[i]-> get_name () << "," ;
  matlab_file << Parameters[Parameters.size ()-1]-> get_name () ;
  matlab_file <<"]';"<< endl ;
  matlab_file.close();

  matlab_file.open ("coord_init.m");
  for ( int i = 0 ; i < Coordinates.size () ; i++ )
        matlab_file << "global " << Coordinates[i]-> get_name () << ";" << endl;
  for ( int i = 0 ; i < Coordinates.size () ; i++ )
        matlab_file << Coordinates[i]-> get_name () << " = " << Coordinates[i]-> get_value () << ";" << endl;
  matlab_file.close();

  matlab_file.open ("coord_vect_init.m");
  for ( int i = 0 ; i < Coordinates.size () ; i++ )
        matlab_file << "global " << Coordinates[i]-> get_name () << ";" << endl;
  matlab_file << "global q;" << endl;
  matlab_file << "q=[" ;
  for ( int i = 0 ; i < Coordinates.size ()-1 ; i++ )
        matlab_file << Coordinates[i]-> get_name () << "," ;
  matlab_file << Coordinates[Coordinates.size ()-1]-> get_name () ;
  matlab_file <<"]';"<< endl ;
  matlab_file.close() ;

  matlab_file.open ("vel_init.m");
  for ( int i = 0 ; i < Velocities.size () ; i++ )
        matlab_file << "global " << Velocities[i]-> get_name () << ";" << endl;
  for ( int i = 0 ; i < Velocities.size () ; i++ )
        matlab_file << Velocities[i]-> get_name () << " = " << Velocities[i]-> get_value () << ";" << endl;
  matlab_file.close();

  matlab_file.open ("vel_vect_init.m");
  for ( int i = 0 ; i < Velocities.size () ; i++ )
        matlab_file << "global " << Velocities[i]-> get_name () << ";" << endl;
  matlab_file << "global dq;" << endl;
  matlab_file << "dq=[" ;
  for ( int i = 0 ; i < Velocities.size ()-1 ; i++ )
        matlab_file << Velocities[i]-> get_name () << "," ;
  matlab_file << Velocities[Velocities.size ()-1]-> get_name () ;
  matlab_file <<"]';"<< endl;
  matlab_file.close();

  matlab_file.open ("unknowns_init.m");
  for ( int i = 0 ; i < Joint_Unknowns.size () ; i++ )
        matlab_file << "global " << Joint_Unknowns[i]-> get_name () << ";" << endl;
  for ( int i = 0 ; i < Joint_Unknowns.size () ; i++ )
        matlab_file << Joint_Unknowns[i]-> get_name () << " = " << Joint_Unknowns[i]-> get_value () << ";" << endl;
  matlab_file.close();

  matlab_file.open ("unknowns_vect_init.m");
  for ( int i = 0 ; i < Joint_Unknowns.size () ; i++ )
        matlab_file << "global " << Joint_Unknowns[i]-> get_name () << ";" << endl;
  matlab_file << "global unknowns;" << endl;
  matlab_file << "unknowns=[" ;
  for ( int i = 0 ; i < Joint_Unknowns.size ()-1 ; i++ )
        matlab_file << Joint_Unknowns[i]-> get_name () << "," ;
  matlab_file << Joint_Unknowns[Joint_Unknowns.size ()-1]-> get_name () ;
  matlab_file <<"]';"<< endl;
  matlab_file.close();

  matlab_file.open ("inputs_init.m");
  for ( int i = 0 ; i < Inputs.size () ; i++ )
        matlab_file << "global " << Inputs[i]-> get_name () << ";" << endl;
  for ( int i = 0 ; i < Inputs.size () ; i++ )
        matlab_file << Inputs[i]-> get_name () << " = " << Inputs[i]-> get_value () << ";" << endl;
  matlab_file.close();

  matlab_file.open ("inputs_vect_init.m");
  for ( int i = 0 ; i < Inputs.size () ; i++ )
        matlab_file << "global " << Inputs[i]-> get_name () << ";" << endl;
  matlab_file << "global inputs;" << endl;
  matlab_file << "inputs=[" ;
  for ( int i = 0 ; i < Inputs.size ()-1 ; i++ )
        matlab_file << Inputs[i]-> get_name () << "," ;
  matlab_file << Inputs[Inputs.size ()-1]-> get_name () ;
  matlab_file <<"]';"<< endl;
  matlab_file.close();


	sys.export_function_MATLAB("Q", "Q_", Q);
	
	sys.export_function_MATLAB("Q_z", "Q_z_", Q_z);

	sys.export_function_MATLAB("Q_d", "Q_d_", Q_d);

	sys.export_function_MATLAB("Qgamma", "Qgamma_", Qgamma);

	sys.export_function_MATLAB("Output", "Output_", Output);

	sys.export_function_MATLAB("Energy", "Energy_", Energy);

	sys.export_function_MATLAB("Phi", "Phi_", Phi);

	sys.export_function_MATLAB("PhiInit", "PhiInit_", PhiInit);

	sys.export_function_MATLAB("dPhi", "dPhi_", dPhi);

	sys.export_function_MATLAB("dPhiInit", "dPhiInit_", dPhiInit);

	sys.export_function_MATLAB("Phi_t", "Phi_t_", Phi_t);

	sys.export_function_MATLAB("minus_Phi_t", "minus_Phi_t_", minus_Phi_t);

	sys.export_function_MATLAB("PhiInit_t", "PhiInit_t_", PhiInit_t);

	sys.export_function_MATLAB("minus_PhiInit_t", "minus_PhiInit_t_", minus_PhiInit_t);

	sys.export_function_MATLAB("M", "M_", M);

	sys.export_function_MATLAB("M_zz", "M_zz_", M_zz);

	sys.export_function_MATLAB("M_zd", "M_zd_", M_zd);

	sys.export_function_MATLAB("M_dd", "M_dd_", M_dd);

	sys.export_function_MATLAB("MXPhi_qZero", "MXPhi_qZero_", MXPhi_qZero);

	sys.export_function_MATLAB("Phi_z", "Phi_z_", Phi_z);

	sys.export_function_MATLAB("Phi_d", "Phi_d_", Phi_d);

	sys.export_function_MATLAB("Phi_q", "Phi_q_", Phi_q);

	sys.export_function_MATLAB("PhiInit_q", "PhiInit_q_", PhiInit_q);

	sys.export_function_MATLAB("dPhi_q", "dPhi_q_", dPhi_q);
	
	sys.export_function_MATLAB("dPhi_t", "dPhi_t_", dPhi_t);

//End Javier
// ************************************************************************************************
// ************************************************************************************************
// ************************************************************************************************


// ************************************************************************************************
// Export C code for Direct Simulation 
// ************************************************************************************************
cout << "Export C code for Direct Simulation" << endl;

	sys.export_var_def_C();							//->"var_def.c"
	sys.export_var_def_H();							//->"var_def.h"
	sys.export_var_init_C();						//->"var_init.c"
	sys.export_gen_coord_vect_def_H();	//->"gen_coord_vect_def.h"
	sys.export_gen_coord_vect_init_C();	//->"gen_coord_vect_init.c"
	sys.export_gen_vel_vect_def_H();		//->"gen_vel_vect_def.h"
	sys.export_gen_vel_vect_init_C();		//->"gen_vel_vect_init.c"
	sys.export_gen_accel_vect_def_H();	//->"gen_accel_vect_def.h"	
	sys.export_gen_accel_vect_init_C();	//->"gen_accel_vect_init.c"
	sys.export_param_vect_def_H();			//->"param_vect_def.h"
	sys.export_param_vect_init_C();			//->"param_vect_init.c"
	sys.export_unknowns_vect_def_H();		//->"unknowns_vect_def.h"
	sys.export_unknowns_vect_init_C();	//->"unknowns_vect_init.c"
	sys.export_inputs_vect_def_H();			//->"inputs_vect_def.h"
	sys.export_inputs_vect_init_C();		//->"inputs_vect_init.c"

	lst	used_atom_list,
	new_atom_list_Phi,
	new_atom_list_PhiInit,
	new_atom_list_dPhi,
	new_atom_list_dPhiInit,
	new_atom_list_Phi_z,
	new_atom_list_Phi_d,
	new_atom_list_Phi_t,
	new_atom_list_minus_Phi_t,
	new_atom_list_PhiInit_t,
	new_atom_list_minus_PhiInit_t,
	new_atom_list_Phi_q,
	new_atom_list_PhiInit_q,
	new_atom_list_dPhi_q,
	new_atom_list_dPhi_t,
	new_atom_list_Q,
	new_atom_list_Q_z,
	new_atom_list_Q_d,
	new_atom_list_Qgamma,
	new_atom_list_M,
	new_atom_list_M_zz,
	new_atom_list_M_zd,
	new_atom_list_M_dd,
	new_atom_list_MXPhi_qZero,
	new_atom_list_Output,
	new_atom_list_Energy;

	new_atom_list_Phi								= atom_list	(Phi							,used_atom_list);
	new_atom_list_PhiInit						= atom_list	(PhiInit					,used_atom_list);
	new_atom_list_dPhi							= atom_list	(dPhi							,used_atom_list);
	new_atom_list_dPhiInit					= atom_list	(dPhiInit					,used_atom_list);
	new_atom_list_Phi_z							= atom_list	(Phi_z						,used_atom_list);
	new_atom_list_Phi_d							= atom_list	(Phi_d						,used_atom_list);
	new_atom_list_Phi_t							= atom_list	(Phi_t						,used_atom_list);
	new_atom_list_minus_Phi_t		= atom_list	(minus_Phi_t	,used_atom_list);
	new_atom_list_PhiInit_t					= atom_list	(PhiInit_t				,used_atom_list);
	new_atom_list_minus_PhiInit_t		= atom_list	(minus_PhiInit_t	,used_atom_list);
	new_atom_list_Phi_q							= atom_list	(Phi_q						,used_atom_list);
	new_atom_list_PhiInit_q					= atom_list	(PhiInit_q				,used_atom_list);
	new_atom_list_dPhi_q						= atom_list	(dPhi_q						,used_atom_list);
	new_atom_list_dPhi_t						= atom_list	(dPhi_t						,used_atom_list);
	new_atom_list_Q									= atom_list	(Q								,used_atom_list);
	new_atom_list_Q_z								= atom_list	(Q_z							,used_atom_list);
	new_atom_list_Q_d								= atom_list	(Q_d							,used_atom_list);
	new_atom_list_Qgamma						= atom_list	(Qgamma						,used_atom_list);
	new_atom_list_M									= atom_list	(M								,used_atom_list);
	new_atom_list_M_zz							= atom_list	(M_zz							,used_atom_list);
	new_atom_list_M_zd							= atom_list	(M_zd							,used_atom_list);
	new_atom_list_M_dd							= atom_list	(M_dd							,used_atom_list);
	new_atom_list_MXPhi_qZero				= atom_list (MXPhi_qZero			,used_atom_list);	
	new_atom_list_Output						= atom_list	(Output						,used_atom_list);
	new_atom_list_Energy	= atom_list	(Energy	,used_atom_list);

#ifdef Col_MO

	#ifdef MAPLE_OFF
	// VECTORS
	sys.export_Column_Matrix_C	("Phi"							,"_Phi"								,Phi							,new_atom_list_Phi);
	sys.export_Column_Matrix_C	("PhiInit"					,"_PhiInit"						,PhiInit					,new_atom_list_PhiInit);
	sys.export_Column_Matrix_C	("dPhi"							,"_dPhi"							,dPhi							,new_atom_list_dPhi);
	sys.export_Column_Matrix_C	("dPhiInit"					,"_dPhiInit"					,dPhiInit					,new_atom_list_dPhiInit);
	sys.export_Column_Matrix_C	("Phi_t"						,"_Phi_t"							,Phi_t						,new_atom_list_Phi_t);
	sys.export_Column_Matrix_C	("minus_Phi_t"	,"_minus_Phi_t"		,minus_Phi_t	,new_atom_list_minus_Phi_t);
	sys.export_Column_Matrix_C	("PhiInit_t"				,"_PhiInit_t"					,PhiInit_t				,new_atom_list_PhiInit_t);
	sys.export_Column_Matrix_C	("minus_PhiInit_t"	,"_minus_PhiInit_t"		,minus_PhiInit_t	,new_atom_list_minus_PhiInit_t);
	sys.export_Column_Matrix_C	("Q"								,"_Q"									,Q								,new_atom_list_Q);
	sys.export_Column_Matrix_C	("Q_z"							,"_Q_z"								,Q_z							,new_atom_list_Q_z);
	sys.export_Column_Matrix_C	("Q_d"							,"_Q_d"								,Q_d							,new_atom_list_Q_d);
	sys.export_Column_Matrix_C	("Qgamma"						,"_Qgamma"						,Qgamma						,new_atom_list_Qgamma);
	sys.export_Column_Matrix_C	("Output"						,"_Output"						,Output						,new_atom_list_Output);
	sys.export_Column_Matrix_C	("Energy"	,"_Energy"	,Energy	,new_atom_list_Energy);

	// MATRIX
	sys.export_Matrix_C	("Phi_z"				,"_Phi_z"				,Phi_z				,new_atom_list_Phi_z				, CMO);
	sys.export_Matrix_C	("Phi_d"				,"_Phi_d"				,Phi_d				,new_atom_list_Phi_d				, CMO);
	sys.export_Matrix_C	("Phi_q"				,"_Phi_q"				,Phi_q				,new_atom_list_Phi_q				, CMO);
	sys.export_Matrix_C	("PhiInit_q"		,"_PhiInit_q"		,PhiInit_q		,new_atom_list_PhiInit_q		, CMO);
	sys.export_Matrix_C	("dPhi_q"				,"_dPhi_q"			,dPhi_q				,new_atom_list_dPhi_q				, CMO);
	sys.export_Matrix_C	("dPhi_t"				,"_dPhi_t"			,dPhi_t				,new_atom_list_dPhi_t				, CMO);
	sys.export_Matrix_C	("M"						,"_M"						,M						,new_atom_list_M						, CMO);
	sys.export_Matrix_C	("M_zz"					,"_M_zz"				,M_zz					,new_atom_list_M_zz					, CMO);
	sys.export_Matrix_C	("M_zd"					,"_M_zd"				,M_zd					,new_atom_list_M_zd					, CMO);
	sys.export_Matrix_C	("M_dd"					,"_M_dd"				,M_dd					,new_atom_list_M_dd					, CMO);
	sys.export_Matrix_C	("MXPhi_qZero"	,"_MXPhi_qZero"	,MXPhi_qZero	,new_atom_list_MXPhi_qZero	, CMO);
	#endif

	#ifdef MAPLE_ON
	sys.export_Matrix_MAPLE("Q", "_Q", Q, CMO);
	system("maple Q.mpl > Q.log"); system("bash ./replace.bash Q_maple_include.c Q_maple_include.c");

	sys.export_Matrix_MAPLE("Q_z", "_Q_z", Q_z, CMO);
	system("maple Q_z.mpl > Q_z.log"); system("bash ./replace.bash Q_z_maple_include.c Q_z_maple_include.c");

	sys.export_Matrix_MAPLE("Q_d", "_Q_d", Q_d, CMO);
	system("maple Q_d.mpl > Q_d.log"); system("bash ./replace.bash Q_d_maple_include.c Q_d_maple_include.c");

	sys.export_Matrix_MAPLE("Qgamma", "_Qgamma", Qgamma, CMO);
	system("maple Qgamma.mpl > Qgamma.log"); system("bash ./replace.bash Qgamma_maple_include.c Qgamma_maple_include.c");

	sys.export_Matrix_MAPLE("Output", "_Output", Output, CMO);
	system("maple Output.mpl > Output.log"); system("bash ./replace.bash Output_maple_include.c Output_maple_include.c");

	sys.export_Matrix_MAPLE("Energy", "_Energy", Energy, CMO);
	system("maple Energy.mpl > Energy.log"); system("bash ./replace.bash Energy_maple_include.c Energy_maple_include.c");

	sys.export_Matrix_MAPLE("Phi", "_Phi", Phi, CMO);
	system("maple Phi.mpl > Phi.log"); system("bash ./replace.bash Phi_maple_include.c Phi_maple_include.c");

	sys.export_Matrix_MAPLE("PhiInit", "_PhiInit", PhiInit, CMO);
	system("maple PhiInit.mpl > PhiInit.log"); system("bash ./replace.bash PhiInit_maple_include.c PhiInit_maple_include.c");

	sys.export_Matrix_MAPLE("dPhi", "_dPhi", dPhi, CMO);
	system("maple dPhi.mpl > dPhi.log"); system("bash ./replace.bash dPhi_maple_include.c dPhi_maple_include.c");

	sys.export_Matrix_MAPLE("dPhiInit", "_dPhiInit", dPhiInit, CMO);
	system("maple dPhiInit.mpl > dPhiInit.log"); system("bash ./replace.bash dPhiInit_maple_include.c dPhiInit_maple_include.c");

	sys.export_Matrix_MAPLE("Phi_t", "_Phi_t", Phi_t, CMO);
	system("maple Phi_t.mpl > Phi_t.log"); system("bash ./replace.bash Phi_t_maple_include.c Phi_t_maple_include.c");

	sys.export_Matrix_MAPLE("minus_Phi_t", "_minus_Phi_t", minus_Phi_t, CMO);
	system("maple minus_Phi_t.mpl > minus_Phi_t.log"); system("bash ./replace.bash minus_Phi_t_maple_include.c minus_Phi_t_maple_include.c");

	sys.export_Matrix_MAPLE("PhiInit_t", "_PhiInit_t", PhiInit_t, CMO);
	system("maple PhiInit_t.mpl > PhiInit_t.log"); system("bash ./replace.bash PhiInit_t_maple_include.c PhiInit_t_maple_include.c");

	sys.export_Matrix_MAPLE("minus_PhiInit_t", "_minus_PhiInit_t", minus_PhiInit_t, CMO);
	system("maple minus_PhiInit_t.mpl > minus_PhiInit_t.log"); system("bash ./replace.bash minus_PhiInit_t_maple_include.c minus_PhiInit_t_maple_include.c");

	sys.export_Matrix_MAPLE("M", "_M", M, CMO);
	system("maple M.mpl > M.log"); system("bash ./replace.bash M_maple_include.c M_maple_include.c");

	sys.export_Matrix_MAPLE("M_zz", "_M_zz", M_zz, CMO);
	system("maple M_zz.mpl > M_zz.log"); system("bash ./replace.bash M_zz_maple_include.c M_zz_maple_include.c");

	sys.export_Matrix_MAPLE("M_zd", "_M_zd", M_zd, CMO);
	system("maple M_zd.mpl > M_zd.log"); system("bash ./replace.bash M_zd_maple_include.c M_zd_maple_include.c");

	sys.export_Matrix_MAPLE("M_dd", "_M_dd", M_dd, CMO);
	system("maple M_dd.mpl > M_dd.log"); system("bash ./replace.bash M_dd_maple_include.c M_dd_maple_include.c");

	sys.export_Matrix_MAPLE("MXPhi_qZero", "_MXPhi_qZero", MXPhi_qZero, CMO);
	system("maple MXPhi_qZero.mpl > MXPhi_qZero.log"); system("bash ./replace.bash MXPhi_qZero_maple_include.c MXPhi_qZero_maple_include.c");

	sys.export_Matrix_MAPLE("Phi_z", "_Phi_z", Phi_z, CMO);
	system("maple Phi_z.mpl > Phi_z.log"); system("bash ./replace.bash Phi_z_maple_include.c Phi_z_maple_include.c");

	sys.export_Matrix_MAPLE("Phi_d", "_Phi_d", Phi_d, CMO);
	system("maple Phi_d.mpl > Phi_d.log"); system("bash ./replace.bash Phi_d_maple_include.c Phi_d_maple_include.c");

	sys.export_Matrix_MAPLE("Phi_q", "_Phi_q", Phi_q, CMO);
	system("maple Phi_q.mpl > Phi_q.log"); system("bash ./replace.bash Phi_q_maple_include.c Phi_q_maple_include.c");

	sys.export_Matrix_MAPLE("PhiInit_q", "_PhiInit_q", PhiInit_q, CMO);
	system("maple PhiInit_q.mpl > PhiInit_q.log"); system("bash ./replace.bash PhiInit_q_maple_include.c PhiInit_q_maple_include.c");

	sys.export_Matrix_MAPLE("dPhi_q", "_dPhi_q", dPhi_q, CMO);
	system("maple dPhi_q.mpl > dPhi_q.log"); system("bash ./replace.bash dPhi_q_maple_include.c dPhi_q_maple_include.c");

	sys.export_Matrix_MAPLE("dPhi_t", "_dPhi_t", dPhi_t, CMO);
	system("maple dPhi_t.mpl > dPhi_t.log"); system("bash ./replace.bash dPhi_t_maple_include.c dPhi_t_maple_include.c");
	#endif

#endif

#ifdef Row_MO

	#ifdef MAPLE_OFF
	// VECTORS
	sys.export_Column_Matrix_C	("Phi"							,"_Phi"								,Phi							,new_atom_list_Phi);
	sys.export_Column_Matrix_C	("PhiInit"					,"_PhiInit"						,PhiInit					,new_atom_list_PhiInit);
	sys.export_Column_Matrix_C	("dPhi"							,"_dPhi"							,dPhi							,new_atom_list_dPhi);
	sys.export_Column_Matrix_C	("dPhiInit"					,"_dPhiInit"					,dPhiInit					,new_atom_list_dPhiInit);
	sys.export_Column_Matrix_C	("Phi_t"						,"_Phi_t"							,Phi_t						,new_atom_list_Phi_t);
	sys.export_Column_Matrix_C	("minus_Phi_t"	,"_minus_Phi_t"		,minus_Phi_t	,new_atom_list_minus_Phi_t);
	sys.export_Column_Matrix_C	("PhiInit_t"				,"_PhiInit_t"					,PhiInit_t				,new_atom_list_PhiInit_t);
	sys.export_Column_Matrix_C	("minus_PhiInit_t"	,"_minus_PhiInit_t"		,minus_PhiInit_t	,new_atom_list_minus_PhiInit_t);
	sys.export_Column_Matrix_C	("Q"								,"_Q"									,Q								,new_atom_list_Q);
	sys.export_Column_Matrix_C	("Q_z"							,"_Q_z"								,Q_z							,new_atom_list_Q_z);
	sys.export_Column_Matrix_C	("Q_d"							,"_Q_d"								,Q_d							,new_atom_list_Q_d);
	sys.export_Column_Matrix_C	("Qgamma"						,"_Qgamma"						,Qgamma						,new_atom_list_Qgamma);
	sys.export_Column_Matrix_C	("Output"						,"_Output"						,Output						,new_atom_list_Output);
	sys.export_Column_Matrix_C	("Energy"	,"_Energy"	,Energy	,new_atom_list_Energy);
	// MATRIX
	sys.export_Matrix_C	("Phi_z"				,"_Phi_z"				,Phi_z				,new_atom_list_Phi_z				, RMO);
	sys.export_Matrix_C	("Phi_d"				,"_Phi_d"				,Phi_d				,new_atom_list_Phi_d				, RMO);
	sys.export_Matrix_C	("Phi_q"				,"_Phi_q"				,Phi_q				,new_atom_list_Phi_q				, RMO);
	sys.export_Matrix_C	("PhiInit_q"		,"_PhiInit_q"		,PhiInit_q		,new_atom_list_PhiInit_q		, RMO);
	sys.export_Matrix_C	("dPhi_q"				,"_dPhi_q"			,dPhi_q				,new_atom_list_dPhi_q				, RMO);
	sys.export_Matrix_C	("dPhi_t"				,"_dPhi_t"			,dPhi_t				,new_atom_list_dPhi_t				, RMO);
	sys.export_Matrix_C	("M"						,"_M"						,M						,new_atom_list_M						, RMO);
	sys.export_Matrix_C	("M_zz"					,"_M_zz"				,M_zz					,new_atom_list_M_zz					, RMO);
	sys.export_Matrix_C	("M_zd"					,"_M_zd"				,M_zd					,new_atom_list_M_zd					, RMO);
	sys.export_Matrix_C	("M_dd"					,"_M_dd"				,M_dd					,new_atom_list_M_dd					, RMO);
	sys.export_Matrix_C	("MXPhi_qZero"	,"_MXPhi_qZero"	,MXPhi_qZero	,new_atom_list_MXPhi_qZero	, RMO);
	#endif

	#ifdef MAPLE_ON
	// ************************************************************************************************
	// MATRIX (MAPLE === Matrices and vectors defined as MATRIX, exported as vector)

	sys.export_Matrix_MAPLE("Q", "_Q", Q, RMO);
	system("maple Q.mpl > Q.log"); system("bash ./replace.bash Q_maple_include.c Q_maple_include.c");

	sys.export_Matrix_MAPLE("Q_z", "_Q_z", Q_z, RMO);
	system("maple Q_z.mpl > Q_z.log"); system("bash ./replace.bash Q_z_maple_include.c Q_z_maple_include.c");

	sys.export_Matrix_MAPLE("Q_d", "_Q_d", Q_d, RMO);
	system("maple Q_d.mpl > Q_d.log"); system("bash ./replace.bash Q_d_maple_include.c Q_d_maple_include.c");

	sys.export_Matrix_MAPLE("Qgamma", "_Qgamma", Qgamma, RMO);
	system("maple Qgamma.mpl > Qgamma.log"); system("bash ./replace.bash Qgamma_maple_include.c Qgamma_maple_include.c");

	sys.export_Matrix_MAPLE("Output", "_Output", Output, RMO);
	system("maple Output.mpl > Output.log"); system("bash ./replace.bash Output_maple_include.c Output_maple_include.c");

	sys.export_Matrix_MAPLE("Energy", "_Energy", Energy, RMO);
	system("maple Energy.mpl > Energy.log"); system("bash ./replace.bash Energy_maple_include.c Energy_maple_include.c");

	sys.export_Matrix_MAPLE("Phi", "_Phi", Phi, RMO);
	system("maple Phi.mpl > Phi.log"); system("bash ./replace.bash Phi_maple_include.c Phi_maple_include.c");

	sys.export_Matrix_MAPLE("PhiInit", "_PhiInit", PhiInit, RMO);
	system("maple PhiInit.mpl > PhiInit.log"); system("bash ./replace.bash PhiInit_maple_include.c PhiInit_maple_include.c");

	sys.export_Matrix_MAPLE("dPhi", "_dPhi", dPhi, RMO);
	system("maple dPhi.mpl > dPhi.log"); system("bash ./replace.bash dPhi_maple_include.c dPhi_maple_include.c");

	sys.export_Matrix_MAPLE("dPhiInit", "_dPhiInit", dPhiInit, RMO);
	system("maple dPhiInit.mpl > dPhiInit.log"); system("bash ./replace.bash dPhiInit_maple_include.c dPhiInit_maple_include.c");

	sys.export_Matrix_MAPLE("Phi_t", "_Phi_t", Phi_t, RMO);
	system("maple Phi_t.mpl > Phi_t.log"); system("bash ./replace.bash Phi_t_maple_include.c Phi_t_maple_include.c");

	sys.export_Matrix_MAPLE("minus_Phi_t", "_minus_Phi_t", minus_Phi_t, RMO);
	system("maple minus_Phi_t.mpl > minus_Phi_t.log"); system("bash ./replace.bash minus_Phi_t_maple_include.c minus_Phi_t_maple_include.c");

	sys.export_Matrix_MAPLE("PhiInit_t", "_PhiInit_t", PhiInit_t, RMO);
	system("maple PhiInit_t.mpl > PhiInit_t.log"); system("bash ./replace.bash PhiInit_t_maple_include.c PhiInit_t_maple_include.c");

	sys.export_Matrix_MAPLE("minus_PhiInit_t", "_minus_PhiInit_t", minus_PhiInit_t, RMO);
	system("maple minus_PhiInit_t.mpl > minus_PhiInit_t.log"); system("bash ./replace.bash minus_PhiInit_t_maple_include.c minus_PhiInit_t_maple_include.c");

	sys.export_Matrix_MAPLE("M", "_M", M, RMO);
	system("maple M.mpl > M.log"); system("bash ./replace.bash M_maple_include.c M_maple_include.c");

	sys.export_Matrix_MAPLE("M_zz", "_M_zz", M_zz, RMO);
	system("maple M_zz.mpl > M_zz.log"); system("bash ./replace.bash M_zz_maple_include.c M_zz_maple_include.c");

	sys.export_Matrix_MAPLE("M_zd", "_M_zd", M_zd, RMO);
	system("maple M_zd.mpl > M_zd.log"); system("bash ./replace.bash M_zd_maple_include.c M_zd_maple_include.c");

	sys.export_Matrix_MAPLE("M_dd", "_M_dd", M_dd, RMO);
	system("maple M_dd.mpl > M_dd.log"); system("bash ./replace.bash M_dd_maple_include.c M_dd_maple_include.c");

	sys.export_Matrix_MAPLE("MXPhi_qZero", "_MXPhi_qZero", MXPhi_qZero, RMO);
	system("maple MXPhi_qZero.mpl > MXPhi_qZero.log"); system("bash ./replace.bash MXPhi_qZero_maple_include.c MXPhi_qZero_maple_include.c");

	sys.export_Matrix_MAPLE("Phi_z", "_Phi_z", Phi_z, RMO);
	system("maple Phi_z.mpl > Phi_z.log"); system("bash ./replace.bash Phi_z_maple_include.c Phi_z_maple_include.c");

	sys.export_Matrix_MAPLE("Phi_d", "_Phi_d", Phi_d, RMO);
	system("maple Phi_d.mpl > Phi_d.log"); system("bash ./replace.bash Phi_d_maple_include.c Phi_d_maple_include.c");

	sys.export_Matrix_MAPLE("Phi_q", "_Phi_q", Phi_q, RMO);
	system("maple Phi_q.mpl > Phi_q.log"); system("bash ./replace.bash Phi_q_maple_include.c Phi_q_maple_include.c");

	sys.export_Matrix_MAPLE("PhiInit_q", "_PhiInit_q", PhiInit_q, RMO);
	system("maple PhiInit_q.mpl > PhiInit_q.log"); system("bash ./replace.bash PhiInit_q_maple_include.c PhiInit_q_maple_include.c");

	sys.export_Matrix_MAPLE("dPhi_q", "_dPhi_q", dPhi_q, RMO);
	system("maple dPhi_q.mpl > dPhi_q.log"); system("bash ./replace.bash dPhi_q_maple_include.c dPhi_q_maple_include.c");

	sys.export_Matrix_MAPLE("dPhi_t", "_dPhi_t", dPhi_t, RMO);
	system("maple dPhi_t.mpl > dPhi_t.log"); system("bash ./replace.bash dPhi_t_maple_include.c dPhi_t_maple_include.c");
	#endif

#endif

// ************************************************************************************************

	lst l;

//	l =	Sp,Lp,Ln,Ww,W,Hn,Hi,Hs,Hb,Rw,Rr,Rx,Bx,Mx,Si,Ss,SR,VS,g,a1,a2,W1,W2,W3,W4,W5,Ki,Li0,Li,Ls0,Ls,L0,L,Ds,Di,
//			q1,q2,q3,q4,q5,q6,
//			*dq1,*ddq1,*dq2,*ddq2,*dq3,*ddq3,*dq4,*ddq4,*dq5,*ddq5,*dq6,*ddq6;

	l = q1,q2,q3,q4,q5,q6;
	sys.export_write_state_file_header_C(l);
	sys.export_write_state_file_C(l);

// ************************************************************************************************
// ************************************************************************************************
//  Export Point, Base and Frame Diagrams 
// ************************************************************************************************
// ************************************************************************************************

/*---------begin  Graphviz export---------*/
#ifdef GRAPHVIZ 
cout << "GRAPHVIZ defined" << endl;

sys.export_Graphviz_dot (  );

//Generate eps figure
    system("dot -Tps   base_diagram.dot -o plain_base_diagram.eps");
        system("latex base_diagram.tex");
    system("dvips base_diagram.dvi -o base_diagram.eps");
//Generate figure eps
    system("dot -Tps   point_diagram.dot -o plain_point_diagram.eps");
        system("latex point_diagram.tex");
    system("dvips point_diagram.dvi -o point_diagram.eps");
//Generate eps figure
    system("dot -Tps   frame_diagram.dot -o plain_frame_diagram.eps");
        system("latex frame_diagram.tex");
    system("dvips base_diagram.dvi -o base_diagram.eps");

#else
cout << "NO GRAPHVIZ defined" << endl;
#endif
/*---------end  Graphviz export---------*/

// ************************************************************************************************

/*---------begin write q, dq, ddq, epsilon, parameters to environment.m---------*/

sys.export_environment_m (  );

/*---------end write q, dq, ddq, epsilon, parameters to environment.m---------*/

// ************************************************************************************************
// ************************************************************************************************

// ************************************************************************************************
// Openscenegraph
// ************************************************************************************************
//The solids must be in /solids directory and the name of each solid must be Sol*.3ds (where * is the name of the asociated frame)

cout << "Export OpenSceneGraph files " << endl;


sys.export_solids_homogeneous_matrix_cpp(  );
sys.export_solids_homogeneous_matrix_h(  );
sys.export_osg_read_file_cpp ( );
sys.export_osg_read_file_h ( );
sys.export_osg_root_cpp (  );
sys.export_osg_root_h ( );

// ************************************************************************************************
// ************************************************************************************************

return 0;

}


